This solution provides a category-theoretic construction of the bridge factorization. This factorization formally separates the computation of abstract physical quantities from their numerical evaluation relative to a specific unit anchor. We conclude with a proof that dimensionless outputs are invariant under changes of the unit anchor.
1. Preliminaries: Dimensions, Units, and Quantities
We establish the foundational algebraic structures for dimensional analysis.
* Dimensions (D): A free abelian group (often represented as a vector space over Q) generated by base dimensions (e.g., Length, Mass, Time). We use multiplicative notation. The identity element 1∈D represents dimensionless quantities.
* Scale Group (S): The group representing changes of unit systems (unit anchors). If D has k base dimensions, S≅(R>0​)k. An element s∈S represents a scaling of the base units.
* Numerical Values (R): The strict symmetric monoidal category of positive real numbers R>0​ under multiplication.
* Scaling Character (χ): A group homomorphism χ:S×D→R>0​ that defines how numerical values transform under a change of units. χ(s,d) is the factor by which the measure of a quantity of dimension d changes when units are scaled by s.
Abstract Quantities (Qty): A strict symmetric monoidal category representing physical quantities independent of any unit system. The dimension function [⋅]:Qty→D assigns a dimension to each quantity.
A measurement assigns a numerical value {X}s​ to a quantity X∈Qty under a unit anchor s∈S. Measurements must satisfy the consistency condition (covariance of measure):
{X}s′​=χ(s′s−1,[X])−1⋅{X}s​.
2. Construction of Categories and Functors
We construct the required categories and functors.
A. Program Category (Pgm)
Pgm is a strict symmetric monoidal category representing the syntax of the programming language or mathematical expressions.
* Objects: Types corresponding to physical dimensions.
* Morphisms: Programs or expressions.
* Monoidal Structure (×): Represents the combination of expressions (e.g., multiplication).
B. Observables Category (Obs)
Obs represents the unit-dependent view of physical quantities. We model Obs as a category whose objects capture how the numerical value of a quantity transforms across all possible unit anchors.
* Objects: Functions f:S→R such that there exists an abstract quantity X∈Qty where f(s)={X}s​. These functions inherently satisfy the consistency condition.
* Monoidal Structure (⊗): Pointwise multiplication: (fX​⊗fY​)(s)=fX​(s)⋅fY​(s). This corresponds to the multiplication of the underlying quantities (fX⋅Y​). Obs is a strict symmetric monoidal category.
C. Bridge Functor (B: Pgm → Obs)
B is a strict symmetric monoidal functor providing the semantic interpretation of programs. It maps a program expression E to its observable representation.
B(E)=fQE​​, where QE​ is the abstract quantity computed by E.
D. Units Quotient (Q: Obs → Obs/∼)
We define the quotient category Obs/∼ as the category of abstract quantities, Qty. The equivalence relation ∼ identifies different representations of the same underlying physical quantity.
The functor Q:Obs→Qty abstracts away the unit-dependent representation.
Q(fX​)=X.
Q is a strict symmetric monoidal functor.
E. Numeric Landing (Ã: Qty → R)
The numeric landing functor extracts a numerical value from an abstract quantity. This requires fixing a specific unit anchor. Let U∈S be the chosen anchor.
We define A~U​:Qty→R as:
A~U​(X)={X}U​.
A~U​ is a strict symmetric monoidal functor because measurement respects multiplication: {X⋅Y}U​={X}U​⋅{Y}U​.
3. Bridge Factorization
We define the analysis functors A and J relative to the anchor U.
* A: Obs → R. The evaluation of an observable in anchor U.
AU​(fX​)=fX​(U)={X}U​.
* J: Pgm → R. The evaluation of a program in anchor U.
JU​(E)=AU​(B(E))={QE​}U​.
We verify the required factorizations.
   1. A = Ã ∘ Q:
(A~U​∘Q)(fX​)=A~U​(Q(fX​))=A~U​(X)={X}U​=AU​(fX​).
   2. J = Ã ∘ B_:
We define $B_: \text{Pgm} \to \text{Qty}$ as the composition B∗​=Q∘B. B∗​ computes the abstract quantity resulting from a program.
B∗​(E)=Q(B(E))=Q(fQE​​)=QE​.
(A~U​∘B∗​)(E)=A~U​(B∗​(E))=A~U​(QE​)={QE​}U​=JU​(E).
This construction successfully provides the required strict symmetric monoidal functors and factorizations.
4. Proof of Invariance of Dimensionless Outputs
Theorem: Dimensionless outputs are invariant under unit anchor changes.
Proof:
      1. Definition: A program E has a dimensionless output if the abstract quantity QE​=B∗​(E) is dimensionless, i.e., [QE​]=1 (the identity element of D).
      2. Goal: We want to show that the numerical evaluation JU​(E) is independent of the anchor U. Let U1​ and U2​ be two different unit anchors in S.
      3. Evaluation: The numerical evaluations are JU1​​(E)={QE​}U1​​ and JU2​​(E)={QE​}U2​​.
      4. Consistency Condition: We use the consistency condition for measurements. Let s=U2​U1−1​∈S be the relative change of units.
{QE​}U2​​=χ(s,[QE​])−1⋅{QE​}U1​​.
      5. Dimensionless Property: Since the output is dimensionless, [QE​]=1.
{QE​}U2​​=χ(s,1)−1⋅{QE​}U1​​.
      6. Homomorphism Property: The scaling character χ is a group homomorphism with respect to the dimension argument. A homomorphism must map the identity element of the source group (1 in D) to the identity element of the target group (1 in R).
Therefore, χ(s,1)=1 for all s∈S.
      7. Conclusion: Substituting this into the equation:
{QE​}U2​​=(1)−1⋅{QE​}U1​​={QE​}U1​​.
Thus, JU2​​(E)=JU1​​(E).
The numerical output of a dimensionless program is invariant under unit anchor changes.